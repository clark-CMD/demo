// ==UserScript==
// @name         扇贝阅读 Safari 阅读模式优化 v0.9 (Hash触发完成)
// @namespace    http://tampermonkey.net/
// @version      0.9
// @description  精确重建内容，保留标记，并在阅读模式末尾添加链接，尝试通过URL哈希变化触发“完成阅读”。
// @author       Your Name & Claude
// @match        https://web.shanbay.com/reading/web-news/articles/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    // --- 配置 ---
    const config = {
        paragraphSelector: '.article-content > .para',
        sentenceSelector: '.sentence',
        wordSelector: '.word',
        boldClass: 'word-bold',
        learnedClass: 'learned',
        titleSelectors: ['h2.article-title', '.article-header h2', 'h1', 'h2'],
        contentContainerSelector: '.article-content',
        originalFinishButtonSelector: 'a.article-button.finish-button',
        finishActionHash: '#shanbayReaderFinishAction', // 用于触发操作的独特哈希值
        debug: true
    };

    // --- 工具函数 ---
    function log(message) {
        if (config.debug) {
            console.log('[Shanbay Reader Mode Fix v0.9] ' + message);
        }
    }

    // --- 哈希变化处理函数 (在原始页面上下文执行) ---
    function handleHashChange() {
        if (location.hash === config.finishActionHash) {
            log(`Hash matched: ${config.finishActionHash}. Attempting to click finish button.`);

            // 查找原始按钮
            const originalButton = document.querySelector(config.originalFinishButtonSelector);
            if (originalButton) {
                try {
                    originalButton.click();
                    log('Original finish button clicked successfully via hash change.');
                } catch (e) {
                    log('Error clicking the original button via hash change: ' + e);
                    alert('尝试点击“完成阅读”按钮时出错，请手动点击。');
                }
            } else {
                log('Error: Original finish button not found when hash changed.');
                alert('错误：无法找到原始的“完成阅读”按钮。');
            }

            // 清除哈希值，防止用户刷新或后退时再次触发
            // 使用 replaceState 避免在历史记录中留下 #shanbayReaderFinishAction
            history.replaceState(null, '', location.pathname + location.search);
            log('URL hash cleared.');
        }
    }

    // --- 添加哈希变化监听器 (只添加一次) ---
    // 检查是否已添加监听器，防止重复添加（虽然影响不大）
    if (!window.shanbayReaderHashListenerAdded) {
        window.addEventListener('hashchange', handleHashChange, false);
        window.shanbayReaderHashListenerAdded = true;
        log('Hash change listener added.');
    }

    // --- 主要逻辑：重建阅读模式内容 ---
    function restructureForReaderMode() {
        log('Starting restructuring process (v0.9)...');

        const marker = 'readerModeRestructured';
        if (document.body.dataset[marker]) {
            log('Already restructured. Skipping.');
            return;
        }

        const contentContainer = document.querySelector(config.contentContainerSelector);
        if (!contentContainer) {
            log(`Error: Could not find content container: ${config.contentContainerSelector}`);
            return;
        }

        // 1. 创建 <article>
        const readerArticle = document.createElement('article');
        readerArticle.className = 'reader-mode-content-generated';

        // 2. 添加标题
        // ... [代码同 v0.8] ...
        let titleText = document.title;
        for (const selector of config.titleSelectors) {
             const titleElement = document.querySelector(selector);
             if (titleElement && titleElement.textContent.trim()) { titleText = titleElement.textContent.trim(); break; }
        }
        const heading = document.createElement('h1'); heading.textContent = titleText; readerArticle.appendChild(heading);


        // 3. 重建段落和标记
        // ... [代码同 v0.8] ...
        let paragraphContainers = contentContainer.querySelectorAll(config.paragraphSelector);
        if (paragraphContainers.length === 0) { paragraphContainers = contentContainer.querySelectorAll('.para'); }
        let paragraphsGenerated = 0;
        paragraphContainers.forEach((paraContainer, paraIndex) => {
             const pElement = document.createElement('p'); pElement.style.margin = '1em 0'; pElement.style.lineHeight = '1.6';
             let contentAddedToParagraph = false;
             const sentenceContainers = paraContainer.querySelectorAll(config.sentenceSelector);
             if (sentenceContainers.length > 0) {
                  sentenceContainers.forEach((sentenceContainer, sentenceIndex) => {
                       sentenceContainer.childNodes.forEach(node => { /* ... 处理单词 b/u/标点/空格 ... */
                            let nodeProcessed = false;
                            if (node.nodeType === Node.ELEMENT_NODE && node.matches('span')) {
                                const wordSpan = node.querySelector(config.wordSelector);
                                if (wordSpan) { const wordText = wordSpan.textContent.trim(); if(wordText){ const isBold=wordSpan.classList.contains(config.boldClass); const isLearned=wordSpan.classList.contains(config.learnedClass); let wordElement=null; if(isBold&&isLearned){wordElement=document.createElement('b');const u=document.createElement('u');u.textContent=wordText;wordElement.appendChild(u);}else if(isBold){wordElement=document.createElement('b');wordElement.textContent=wordText;}else if(isLearned){wordElement=document.createElement('u');wordElement.textContent=wordText;}else{wordElement=document.createTextNode(wordText);} pElement.appendChild(wordElement); contentAddedToParagraph=true; nodeProcessed=true;} }
                                else if (node.textContent.trim()===''&&contentAddedToParagraph&&pElement.lastChild&&(!pElement.lastChild.textContent||!pElement.lastChild.textContent.endsWith(' '))){pElement.appendChild(document.createTextNode(' '));nodeProcessed=true;}
                            } else if (node.nodeType===Node.TEXT_NODE){ const punctuation=node.textContent.trim(); if(punctuation){ if(pElement.lastChild&&pElement.lastChild.nodeType===Node.TEXT_NODE&&pElement.lastChild.textContent.endsWith(' ')){pElement.lastChild.textContent=pElement.lastChild.textContent.trimEnd();} pElement.appendChild(document.createTextNode(punctuation)); contentAddedToParagraph=true; nodeProcessed=true;} else if(node.textContent.includes(' ')&&contentAddedToParagraph&&pElement.lastChild&&(!pElement.lastChild.textContent||!pElement.lastChild.textContent.endsWith(' '))){pElement.appendChild(document.createTextNode(' '));nodeProcessed=true;} }
                            if(!nodeProcessed&&node.nodeType===Node.ELEMENT_NODE&&contentAddedToParagraph&&pElement.lastChild&&(!pElement.lastChild.textContent||!pElement.lastChild.textContent.endsWith(' '))){ if(node.textContent.includes(' ')){pElement.appendChild(document.createTextNode(' '));} }
                       });
                       if (sentenceIndex<sentenceContainers.length-1&&contentAddedToParagraph&&pElement.lastChild&&(!pElement.lastChild.textContent||!pElement.lastChild.textContent.endsWith(' '))) { pElement.appendChild(document.createTextNode(' ')); }
                  });
             }
             if (contentAddedToParagraph && pElement.textContent.trim()) {
                 if (pElement.lastChild && pElement.lastChild.nodeType === Node.TEXT_NODE && pElement.lastChild.textContent.endsWith(' ')) { pElement.lastChild.textContent = pElement.lastChild.textContent.trimEnd(); }
                  if (pElement.textContent.trim()) { readerArticle.appendChild(pElement); paragraphsGenerated++; }
             }
        }); // end of paragraphs loop


        log(`Generated ${paragraphsGenerated} paragraphs.`);

        // 4. **添加触发链接 (替换之前的提示)**
        const originalButton = document.querySelector(config.originalFinishButtonSelector);
        if (originalButton) {
            log('Original finish button found. Adding trigger link.');
            const triggerLink = document.createElement('a');
            triggerLink.href = config.finishActionHash; // 指向特殊哈希
            triggerLink.textContent = originalButton.textContent.trim() || '完成阅读';
            // 添加一些样式让它看起来像个链接/按钮
            triggerLink.style.display = 'block';
            triggerLink.style.marginTop = '2em';
            triggerLink.style.padding = '10px';
            triggerLink.style.border = '1px solid #007aff'; // 蓝色边框
            triggerLink.style.borderRadius = '5px';
            triggerLink.style.textAlign = 'center';
            triggerLink.style.color = '#007aff'; // 蓝色文字
            triggerLink.style.textDecoration = 'none';
            triggerLink.style.fontWeight = 'bold';
            triggerLink.style.maxWidth = '200px';
            triggerLink.style.marginLeft = 'auto';
            triggerLink.style.marginRight = 'auto';

            readerArticle.appendChild(triggerLink);
            log('Trigger link added.');
        } else {
            log('Original finish button not found. Cannot add trigger link.');
        }

        // 5. 添加元数据
        readerArticle.setAttribute('role', 'article');
        readerArticle.setAttribute('itemscope', '');
        readerArticle.setAttribute('itemtype', 'http://schema.org/Article');
        const headlineMeta = document.createElement('meta');
        headlineMeta.setAttribute('itemprop', 'headline');
        headlineMeta.setAttribute('content', heading.textContent);
        if (readerArticle.firstChild) { readerArticle.insertBefore(headlineMeta, readerArticle.firstChild.nextSibling); }
        else { readerArticle.appendChild(headlineMeta); }

        // 6. 插入页面并隐藏原始内容
        const parentOfOriginalContent = contentContainer.parentNode;
        if (parentOfOriginalContent) {
            parentOfOriginalContent.insertBefore(readerArticle, contentContainer);
            log('Generated <article> injected.');
            contentContainer.style.display = 'none';
            log('Original content container hidden.');
        } else {
            log('Error: Could not find parent node. Appending to body fallback.');
            document.body.prepend(readerArticle);
        }

        document.body.dataset[marker] = 'true';
        log('Restructuring complete (v0.9).');
    }

    // --- 执行脚本 ---
    // ... [MutationObserver 和 tryRun 代码同 v0.8] ...
     const observer = new MutationObserver((mutationsList, obs) => {
         const targetContent = document.querySelector(config.contentContainerSelector);
         if (targetContent && !document.body.dataset.readerModeRestructured) {
             log('Content container detected via MutationObserver. Running restructuring...');
             setTimeout(restructureForReaderMode, 500);
             // obs.disconnect();
         }
     });
     observer.observe(document.body, { childList: true, subtree: true });
     function tryRun() {
         if (document.querySelector(config.contentContainerSelector) && !document.body.dataset.readerModeRestructured) {
             log('Content container found on initial check. Running restructuring...');
             setTimeout(restructureForReaderMode, 500);
         } else {
             log('Content container not found yet or already restructured.');
         }
     }
     if (document.readyState === 'complete' || document.readyState === 'interactive') { tryRun(); }
     else { window.addEventListener('DOMContentLoaded', tryRun); window.addEventListener('load', tryRun); }

})();
